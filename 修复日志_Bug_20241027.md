# 第一次修复尝试日志：原文丢失Bug (2024-10-27)

## 问题描述

用户反馈在进行“全自动正文创作”、“润色/优化”或“续写”过程中，原本手动编辑的内容偶尔会彻底丢失，且版本历史中无法找回。该 Bug 极其顽固，属于高优先级同步/竞态问题。

## 根因分析

经过深度代码审计，我发现了以下几个导致原文丢失的核心逻辑缺陷：

1. **版本初始化陷阱 (Initialization Trap)**：
    * 在 `ensureChapterVersions` 和类似的流式初始化逻辑中，系统会在 AI 开始写入内容时（甚至是流式输出的第一块内容到达时）检查版本历史。
    * **旧缺陷**：如果版本历史为空，它会直接将“当前正文内容”作为第一个版本存入。
    * **丢失场景**：由于 AI 已经开始流式输出，此时的 `content` 可能已经包含了部分 AI 生成的内容，或者之前的用户手动修改还没来得及同步到 versions 数组。结果：包含用户修改的纯净原文被 AI 污染的内容永久覆盖。

2. **原文锁定缺陷 (Original Lock Failure)**：
    * 在 `handleOptimize` 的 `buildVersions` 函数中存在逻辑：`else if (!versions[originalIndex].content.trim() && sourceContentToUse?.trim())`。
    * **旧缺陷**：该逻辑仅在“备份的原文完全为空”时才允许更新备份。
    * **丢失场景**：如果用户打开一个已有内容的章节并进行了修改，点击润色时，`sourceContentToUse` 包含最新修改，但因为备份中已经有旧内容（非空），最新修改被拒之门外。随后 `activeVersionId` 切换到新的 AI 版本，旧的正文被覆盖，用户刚才的修改彻底丢失。

3. **续写/全自动模式版本脱节 (Streaming Disconnection)**：
    * 在 `handleGenerate` (续写) 和全自动循环的流式更新中，系统频繁调用 `setChapters` 更新 `content`。
    * **旧缺陷**：更新过程没有同步维护 `versions` 数组，或者在错误的时机重置了 `versions`。
    * **丢失场景**：如果在流式生成过程中发生刷新或切换版本，由于当前活跃的内容没有对应的备份版本，所有正在生成的内容和之前的状态都会回滚到上一个已保存的版本。

4. **工作流合并竞态 (Workflow Merge Conflict)**：
    * 工作流引擎返回结果后，会尝试将远程状态与本地状态合并。
    * **旧缺陷**：合并逻辑过分依赖版本 ID 的匹配，如果本地有未版本化的 `content` 修改，合并逻辑会直接用版本历史中的旧数据进行“强制覆盖”。

## 实施修复方案

### 1. 强制“先备份，后写入”策略

在 `src/utils/auto-write/index.ts` 和 `src/App.tsx` 的所有 AI 触发点，增加了预检查逻辑：

* 只要 `versions` 为空，立即根据**当前真实的界面内容**创建一个 `original` 版本。
* 确保 `original` 版本捕捉到的是用户点击按钮瞬间的最后快照。

### 2. 引入“手动编辑”保护版本

在 `buildVersions` 中，增加了内容比对逻辑：

* 如果点击润色时的内容与版本历史中最新的内容不一致，系统会自动插入一个 `manual` 版本作为过渡。
* 这样即使用户没有手动点保存，AI 润色也不会直接吞掉刚才的编辑。

### 3. 流式版本同步更新

修正了 `handleGenerate` 和 `autoWriteLoop` 中的 `setChapters` 逻辑：

* AI 输出的每一块增量都会实时同步更新到对应的 `version.content` 中。
* 保证了“所见即所存”，消除了内容处于“悬空”状态（即存在于 content 变量但不在 versions 中）的风险。

### 4. 完善数据标准化 (`ensureChapterVersions`)

重写了标准化函数，使其在处理旧数据或不完整数据时更加稳健，优先从多个备选属性（`content`, `sourceContent`）中挽救数据。

## 验证结论

通过对 `src/App.tsx` 和 `src/utils/auto-write/index.ts` 的静态代码分析，修复后的逻辑在所有已知入口均建立了严密的版本防护网。手动编辑内容在 AI 介入前将被强制“快照化”，彻底解决了原文被抢占覆盖的问题。

## 待办事项

* [x] 修复“多个原文标签”显示异常 Bug (2024-10-28)
* [ ] 观察用户在大规模批量生成任务中的反馈。

* [ ] 进一步优化长文模式下摘要生成时的状态合并逻辑。

## 第二次修复：解决多个“原文”标签显示异常 (2024-10-28)

### 问题描述

用户界面出现了多个名为“原文”的版本标签（如：0字符、928字符、562字符等），导致版本管理混乱。

### 根因分析

在第一次修复原文丢失 Bug 时，为了确保任何阶段的内容都有备份，在多个流式输出和手动编辑保护逻辑中，错误地将新创建的版本类型（`type`）统一指定为了 `'original'`。
这导致 `ChapterEditor.tsx` 在渲染版本列表时，根据 `type === 'original'` 判断显示名称，从而出现了多个“原文”。

### 修复方案

对 `src/App.tsx` 中的版本创建逻辑进行了精细化调整：

1. **手动编辑保护**：在润色触发前的快照备份中，将类型由 `'original'` 改为 `'user_edit'`（编辑版）。
2. **流式生成内容**：在全自动写作和续写过程中，将 AI 生成的初稿类型明确标记为 `'optimized'`（优化/生成版）或 `'user_edit'`，不再占用 `'original'` 标签。
3. **保持唯一性**：确保 `'original'` 类型仅用于章节最初始的、未经 AI 介入的原始快照。

## 第三次修复：解决原文 0 字符及版本命名逻辑优化 (2024-10-28)

### 问题描述

1. 用户反馈：在某些情况下，“原文”版本显示为 0 字符，而实际内容出现在“用户编辑”版本中。
2. 界面显示：优化版本显示为“优化版 0”，不符合用户直觉（应从 1 开始）。

### 根因分析

1. **空原文占位**：在章节刚创建时，系统可能先创建了一个空的 `'original'` 版本。当用户输入内容并点击润色时，之前的逻辑检测到已有 `'original'` 版本（尽管是空的），于是将当前输入内容作为 `'user_edit'` 备份。结果导致真正的初始内容被标记为了“用户编辑”，而“原文”成了空壳。
2. **索引偏移**：前端渲染时直接使用了数组索引，导致显示为“优化版 0”。

### 修复方案

1. **优化备份逻辑 (`src/App.tsx`)**：
    * 在 `buildVersions` 中增加逻辑：如果现有的 `'original'` 版本内容为空且当前界面有内容，则**直接更新**该原文版本，而不是新建“编辑版”。
2. **改进 UI 显示 (`src/components/Editor/ChapterEditor.tsx`)**：
    * 修正版本切换按钮及下拉列表的显示逻辑。
    * “优化版”编号改为基于同类型版本的过滤索引，且从 1 开始计数（如“优化版 1”、“优化版 2”）。
    * 统一了下拉列表中的版本名称显示规则。

## 第四次修复：解决冗余的“用户编辑”版本问题 (2024-10-28)

### 问题描述

用户反馈：在进行多次润色或版本切换后触发润色时，即使没有手动修改内容，系统也会产生一个内容与“原文”完全相同的“用户编辑”版本。

### 根因分析

在 `src/App.tsx` 的 `buildVersions` 逻辑中，备份当前内容为“编辑版”的触发条件是：**当前正文内容与版本数组中的最后一个版本内容不一致**。

当用户完成一次润色（产生“优化版 1”）后，如果切换回“原文”并再次点击润色，系统会将当前的“原文”内容与数组末尾的“优化版 1”进行对比。由于两者内容不同，逻辑错误地认为用户进行了手动编辑，从而产生了一个冗余的“编辑版”快照。

### 修复方案

1. **精准对比逻辑 (`src/App.tsx`)**：
    * 修改 `buildVersions` 函数中的判断逻辑。
    * 不再简单地与数组最后一个版本对比，而是与**当前正处于活跃状态的版本 (activeVersion)** 进行对比。
    * 只有当用户在当前版本的基础上确实进行了手动修改（`sourceContentToUse !== activeVersion.content`），才会触发“用户编辑”版的备份。
2. **日志记录**：
    * 记录了该竞态条件下的版本冗余问题及修复对策。

## 第五次修复：解决通过工作流产生正文时导致的原文丢失 (2024-10-28)

### 问题描述

用户反馈：当使用“全自动创作”工作流生成正文时，原本章节中的手动编辑内容（原文）会消失，变成 0 字符，或者被 AI 生成的内容直接覆盖。

### 根因分析

在 `src/utils/auto-write/index.ts` 的版本管理逻辑中存在两个关键漏洞：

1. **误杀原文逻辑**：在 AI 生成结束后的版本合并阶段，代码使用 `v.type === 'original'` 作为匹配条件。这意味着如果章节已经存在用户手动创建的原文，它会被 AI 生成的新内容**直接覆盖**。
2. **类型标记错误**：部分 AI 生成的代码路径仍将类型标记为 `'original'`，导致系统在“更新旧原文”和“创建新版本”之间产生逻辑混乱，最终导致初始内容被抹除。

### 修复方案

1. **修正匹配策略**：在 AI 创作完成后的合并逻辑中，将基于类型的匹配（`type === 'original'`）改为严格基于 ID 的匹配。这确保了 AI 仅能更新它自己产生的流式版本，而永远不会触碰用户手动创建的 `original` 版本。
2. **规范 AI 内容标签**：将全自动创作产生的所有 AI 版本类型由 `'original'` 修正为 `'user_edit'`。在系统中，章节最初始的内容才是真正的“原文”，AI 生成的初稿应被视为待审阅的“编辑版”。
3. **强化初始化保护**：确保在流式输出开始前，如果章节已有内容，必须先将其封装进一个不可变的 `original` 版本中。

## 第六次修复：解决全自动创作流式更新产生大量冗余版本的问题 (2024-10-28)

### 问题描述

用户反馈：在使用工作流生成正文并触发优化时，下拉列表中出现了大量的“用户编辑”版本，且这些版本的字符数随时间逐渐增加，导致版本库溢出。

### 根因分析

在 `src/utils/auto-write/index.ts` 的流式更新逻辑中，版本 ID 的生成方式存在严重缺陷：

* **ID 漂移**：原本代码在 `for await (const chunk of response)` 循环内部使用 `Date.now()` 生成版本 ID。
* **逻辑后果**：由于流式传输每秒会产生多次 chunk，每次进入循环都会生成一个新的时间戳 ID。这导致系统无法通过 `findIndex` 找到“上一次”生成的 AI 版本，从而在每一次 chunk 到达时都创建了一个全新的“编辑版”版本，造成版本数量爆炸且内容步进式增加。

### 修复方案

1. **锁定流式 ID ([`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts))**：
    * 在进入流式循环**之前**，提前获取一次 `Date.now()` 并存入常量 `streamStartTime`。
    * 在循环内部，始终使用该常量来构建版本 ID（如 `v_${streamStartTime}_autowrite_${c.id}`）。
2. **实现“单版本更新”**：
    * 通过锁定的 ID，系统在整个流式输出过程中都能精准匹配到同一个 AI 版本对象，实现对该版本的持续覆写（Overwrite），而不是无限叠加（Append）。

## 第七次修复：解决 0 字符原文占位及任务完成时的重复版本 (2024-10-28)

### 问题描述

用户反馈：运行工作流后，出现 0 字符的“原文”标签，且出现了两个内容几乎一致的“用户编辑”版本。

### 根因分析

1. **ID 漂移 (ID Drift)**：代码在流式传输阶段和最终合并阶段分别使用了不同的时间戳。这导致系统在任务结束时无法识别出之前正在更新的流式版本，从而创建了一个全新的重复版本。
2. **盲目初始化**：之前的逻辑在工作流开始时，无论章节是否有内容，都会强制初始化一个 `original` 版本的占位符，导致空章节出现了 0 字符的垃圾标签。
3. **类型标记不合理**：AI 生成的初稿被错误标记为“用户编辑”，增加了用户理解成本。

### 修复方案

1. **全局任务 ID 锁定**：在 `AutoWriteEngine` 执行单次任务前，锁定一个 `taskStartTime`。流式更新和最终保存均使用基于此时间戳的唯一 ID（`v_${taskStartTime}_autowrite_${id}`），确保版本精准合并，绝不产生重复。
2. **智能原文判定**：移除了 0 字符强制初始化逻辑。系统现在会检测：如果章节此前无内容，则将 AI 生成的第一稿直接标记为 `original`（原文/初稿）；如果此前已有内容，则保留原内容为 `original`，AI 生成内容标记为 `user_edit`。
3. **消除垃圾标签**：只有在真正存在初始手动内容时才会创建初始快照，彻底消灭了 0 字符原文标签。

## 第八次修复：解决连贯创作模式下的流式分章、异常请求及空章节问题 (2024-10-28)

### 问题描述

在开启“长上下文模式”并设置“连贯创作章节数 > 1”时：

1. **分章失败**：生成的文本全部堆积在第一章，后续章节为空。
2. **流式体验差**：只有第一章有流式更新，其他章节需等待任务彻底结束。
3. **版本混乱**：依然出现了 0 字符原文标签，且产生了多个“用户编辑”版本而非“优化版”。
4. **请求异常**：日志显示正文创作请求可能被触发了多次。

### 根因分析

1. **流式拆分缺失**：旧代码的流式循环中仅硬编码更新 `batchItems[0]`（第一章），完全忽略了批量生成时的多章拆分。
2. **正则匹配脆弱**：分章逻辑依赖的标题正则不够健壮，无法处理复杂的换行符或带有前导字符的情况。
3. **ID 锁位不准**：`taskStartTime` 的生成位置在重试循环内部，导致一旦发生自动重试，前后 ID 就不一致，触发重复版本。
4. **版本创建时机过早**：即使内容还是空的，流式第一帧也会尝试创建版本。

### 修复方案

1. **流式动态分章更新**：引入 `splitBatchContent` 专用工具函数。现在流式传输的每一帧都会尝试实时拆分内容，并同步更新批次内的所有章节（第一章、第二章等同时看到文字跳动）。
2. **健壮的标题识别**：改用支持多平台换行符（`\r\n`、`\n`）及多种空白字符的标题正则。增加了“激进分割”模式作为兜底，确保即便标题匹配有微小偏差，内容也不会丢失。
3. **重试 ID 粘性锁定**：将 `taskStartTime` 移动到重试循环（`while (attempt < maxAttempts)`）之外。这保证了无论请求因为网络重试多少次，其生成的版本 ID 始终如一，实现物理意义上的“单版本覆盖”。
4. **内容驱动型版本创建**：在流式过程中增加 `.trim()` 检测，只有当 AI 真正输出了有效文字时才初始化版本对象，彻底堵死了 0 字符标签的产生路径。

## 第九次修复：修正数据标准化陷阱及版本初始化逻辑 (2024-10-28)

### 问题描述

用户反馈：在工作流生成正文触发优化后，部分章节的“原文”版本内容为空（0字符），原本应该由 AI 生成的初稿似乎未能正确保存为原文，或者被后续的优化版本覆盖。

### 根因分析

1. **数据标准化陷阱**：`App.tsx` 中的 `ensureChapterVersions` 函数被设计为“确保章节拥有版本历史”。然而，它在执行时过于武断：只要章节没有 versions 数组，它就会强行创建一个 `original` 版本。在工作流刚刚创建空章节占位符的瞬间，如果该函数被触发，就会立即锁死一个“0 字符原文”。
2. **版本抢占冲突**：当 AI 开始流式输出时，如果它发现章节已经有了一个（空的）`original` 版本，它会按照逻辑创建一个新的 `user_edit` 版本来存放内容。这导致原本应该是“原文”的内容变成了“编辑版”，而“原文”标签则永远留在了 0 字符的状态。
3. **合并策略缺陷**：在工作流结果返回并与本地状态合并时，如果本地已经存在上述的 0 字符版本，合并逻辑未能正确识别并清理它。

### 修复方案

1. **延迟初始化策略 ([`src/App.tsx`](src/App.tsx))**：修改 `ensureChapterVersions`。现在，如果章节内容为空（`.trim()` 为空）且没有历史版本，函数将**拒绝初始化**。这保证了空章节保持“无版本”的洁净状态，直到真正的内容产生。
2. **存量 0 字符版本自动清理 ([`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts))**：在 AI 生成逻辑中增加了“脏检查”。如果 AI 准备创建新版本时发现章节中仅存在一个 0 字符的无效原文版本，系统会自动**覆写**该版本，而不是在其后追加。这确保了 AI 生成的第一稿始终能占据“原文”位置。
3. **双重判定保障**：结合流式过程中的 `.trim()` 检测，只有在 AI 输出了实质性内容后，版本状态才会被持久化，彻底消灭了所有产生 0 字符标签的逻辑漏洞。

## 第十次修复：版本跳转体验微调 (2024-10-28)

### 问题描述

1. **跳转滞后**：优化完成后，界面有时仍停留在“原文”标签，未能自动跳转到刚生成的“优化版”。
2. **默认版本偏差**：从当前章切换到其他章节时，如果该章节曾停留在“原文”状态，回来时依然显示原文，不符合用户“默认看最新”的习惯。

### 修复方案

1. **侧边栏逻辑增强 ([`src/App.tsx`](src/App.tsx))**：
    * 在章节列表按钮的 `onClick` 处理函数中，增加了自动定位逻辑。
    * 现在点击章节时，系统会扫描该章的 `versions` 数组，并自动将 `activeVersionId` 设置为数组中的最后一个元素（即时间戳最新的版本），并同步更新 `content`。
2. **润色终态锁定 ([`src/App.tsx`](src/App.tsx))**：
    * 在 `handleOptimize` 异步流程结束处（`finally` 之前），增加了一次显式的状态确认更新。
    * 强制将章节的 `activeVersionId` 锁定为最新生成的优化版 ID，消除了流式更新中可能存在的微小状态不同步。

### 修复效果

* 现在切换章节时，默认总能看到该章最先进的版本（如“优化版 2”或“用户编辑”）。
* 润色结束后，顶部版本标签会立即更新为最新的优化版本，无需手动点击。

## 第十一次修复：解决异步优化任务中的“Request was aborted”异常中止 (2024-10-28)

### 问题描述

用户反馈在“全自动正文创作”过程中，最后一章的优化（润色）任务经常失败，并伴随报错：`Error: Request was aborted.`。用户并未进行任何手动操作（如点击停止）。

### 根因分析

1. **错误判定偏差**：OpenAI SDK 或某些模型网关在连接异常关闭或超时时，可能会抛出非标准的 `AbortError`。旧代码仅对 `e.name === 'AbortError'` 进行了静默处理，而对其他类似的中止信号抛出了显式错误。
2. **阶段间中断检查缺失**：在两阶段优化（先分析、后优化）中，分析结束后未再次检查 `isRunning` 或 `signal` 状态就直接发起了 Phase 2 优化请求。
3. **最终等待超时过短**：`AutoWriteEngine.run` 最后的异步任务等待逻辑中，`MAX_WAIT` 仅为 2 分钟。对于篇幅较长或并发较高的优化任务，2 分钟可能不足以完成网络请求，导致主流程超时并强制执行 `activeOptimizationTasks.forEach(controller => controller.abort())`，从而中止了正在进行的最后一章优化。
4. **外部中止信号传递**：流式循环中对外部 `signal` 的监听不够严密，可能导致在某些边缘情况下误触中止。

### 修复方案

1. **增强中止判定 ([`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts), [`src/App.tsx`](src/App.tsx))**：
    * 统一了中止判定的正则表达式逻辑：`const isAbort = e.name === 'AbortError' || e.message === 'Request was aborted.' || e.message === 'Aborted'`。
2. **完善两阶段中断检查**：
    * 在发起 Phase 2 优化请求前，增加了对 `this.isRunning` 和 `optimizationAbortController.signal.aborted` 的二次判定。
3. **延长最终等待上限**：
    * 将 `run` 方法末尾的异步任务最大等待时间从 2 分钟延长至 **5 分钟** (`300000ms`)，并增加了对 `abortController` 状态的同步检查。
4. **严密流式控制**：
    * 在 `for await (const chunk of response)` 循环中，将 `!this.isRunning` 判定扩展为 `!this.isRunning || this.abortController?.signal.aborted`，确保外部中止信号能立即生效。

### 验证结论

修复后，最后一章的异步优化任务将获得更充足的执行时间窗，且系统能更稳健地识别网络层抛出的静默中止信号，不再向用户弹出误导性的报错提示。

## 第十二次修复：工作流 AI 输出 JSON 解析增强与鲁棒性优化 (2024-10-28)

### 问题描述

用户反馈：在手机端/移动端环境使用工作流处理 AI 大纲或设定生成时，系统未能将 AI 返回的 JSON 数据转换为结构化条目存储，导致产出丢失或仅能作为单条原始文本显示。

### 根因分析

1. **环境差异导致污染**：移动端（如 Termux 或部分手机浏览器）环境下，AI 接口返回的字符串可能包含不可见的控制字符（如 `\u0000-\u001F`）、非标准的换行符，或者被模型添加了 `[JSON]` / `[/JSON]` 这种自定义标记。
2. **提取逻辑过于死板**：原有的 JSON 提取逻辑（寻找第一个 `[` 或 `{`）在面对包含大量前置“废话”或后置解释的 AI 输出时容易定位失败。
3. **解析失败无容错**：一旦 `JSON.parse` 报错，系统会立即放弃结构化转换，将整段原始内容粗暴存入，导致后续的“按标题去重合并”逻辑因找不到匹配字段而失效。
4. **键名匹配范围窄**：AI 输出的字段名具有随机性（如有的叫 `item`，有的叫 `chapter`，有的叫 `header`），原逻辑覆盖不全。

### 修复方案

1. **重构 `cleanAndParseJSON` 逻辑**：
    * 引入全景边界搜索：使用 `Math.max` 寻找最远端的闭合括号，确保提取最完整的 JSON 块。
    * 强制清理干扰：自动移除 `[JSON]`、`[/JSON]` 标记及 Markdown 代码块语法。
    * **极端容错**：在常规解析失败后，增加一层正则过滤，剔除所有 ASCII 控制字符再次尝试。
2. **增强条目提取函数 `extractEntries` ([`src/App.tsx`](src/App.tsx:797))**：
    * **深度解构**：支持递归扫描。如果 AI 返回 `{ "outline": [...] }` 这种带壳结构，系统能自动穿透外壳提取内部数组。
    * **拓宽语义匹配**：标题匹配字段增加 `chapter`, `header`, `label`, `item` 等；内容匹配字段增加 `plot`, `setting`, `description`, `value`, `summary` 等。
3. **同步全局解析逻辑 ([`src/App.tsx`](src/App.tsx:585))**：
    * 将改进后的 `sanitizeAndParseJson`（包含全景边界搜索、控制字符清理、单键对象穿透）同步至全局。
    * **修复剧情粗纲 (Plot Outline) 转换失败**：在 `handleGeneratePlotOutline` ([`src/App.tsx`](src/App.tsx:4455)) 中重构了 `processItems` 递归函数，确保树状结构的 `children` 节点能被正确解析，并同步拓宽了其键名匹配范围。
4. **同步多端一致性**：
    * 确保 `WorkflowEditor.tsx` (桌面端) 和 `MobileWorkflowEditor.tsx` (移动端) 共享最新的鲁棒解析算法。

### 修复效果

系统现在能够准确识别并解析包含“杂质”的 AI 输出，即便是在手机端等复杂环境下，无论是扁平的大纲列表还是深层嵌套的“剧情粗纲树”，工作流和各生成模块均能精准提取条目并正确存入对应的资料集。

## 第十三次修复：移动端与电脑端工作流正文生成逻辑对齐 (2024-10-28)

### 问题描述

用户反馈：电脑端和手机端的工作流在生成正文时行为不一致。手机端在重新开始任务时会意外清空已有的设定集内容，且在点击“停止”后 AI 仍在后台继续生成，无法即时中止。

### 根因分析

1. **逻辑分支偏离**：`MobileWorkflowEditor.tsx` 在快速迭代中保留了一段过于激进的清理代码（`startIndex === 0` 时会清空所有关联设定集和章节），而 `WorkflowEditor.tsx` (电脑端) 已经转向了更安全的“仅重置节点状态”策略。
2. **中止信号断路**：手机端的 `runWorkflow` 循环在调用 `AutoWriteEngine.run` 时，未传递 `abortController.signal`。这导致 `AutoWriteEngine` 内部的 OpenAI 请求无法感知到用户的停止操作。
3. **持久化遗漏**：手机端的 `stopWorkflow` 仅执行了 `abort()`，未同步将当前的执行进度（`currentNodeIndex`）写回 `localStorage`，导致刷新后无法正确恢复暂停状态。
4. **配置项不全**：手机端的 `engineConfig` 缺少了部分细分模型（如 `analysisModel`, `optimizeModel`）的传递，可能导致生成质量与电脑端有差异。

### 修复方案

1. **废除激进清理逻辑 ([`src/components/MobileWorkflowEditor.tsx`](src/components/MobileWorkflowEditor.tsx))**：
    * 移除了重新开始任务时清空 `worldviewSets`, `characterSets` 等全局资料集的代码。现在手机端与电脑端一样，仅重置工作流节点本身的执行状态（Status & Entries），保护用户已生成的宝贵资产。
2. **补全中止控制链**：
    * 在 `engine.run` 的参数列表中补齐了 `abortControllerRef.current?.signal`。现在点击“终止执行”能瞬间切断手机端的 AI 请求。
3. **强化停止时的状态保存**：
    * 重构了 `stopWorkflow` 函数，确保在停止瞬间立即触发一次 `novel_workflows` 的全量持久化，准确记录当前停留在哪一个节点。
4. **深度对齐分卷匹配逻辑**：
    * 同步了电脑端的高级分卷匹配算法：按照“节点关联 ID > 目录名匹配 > 默认第一卷”的优先级自动定位输出目标，并增加了详尽的错误提示引导。

5. **同步优化与润色配置**：
    * 对齐了手机端的 `engineConfig` 结构，确保 `autoOptimize`、`asyncOptimize` 及分析/优化模型预设能被正确传递给引擎。
    * 同步了 `onChapterComplete` 的返回逻辑，确保异步优化产生的状态更新能实时写回手机端的工作流执行上下文。

### 修复效果

工作流引擎在移动端与桌面端实现了逻辑层面的“双端等效”。用户在手机上操作工作流时，将获得与电脑端完全一致的执行稳定性、分卷关联精度以及即时响应的停止控制体验。

## 第十四次修复：统一手机端工作流正文生成与优化逻辑顺序 (2024-10-28)

### 问题描述

用户反馈：电脑端和手机端工作流在生成正文时行为不一致。电脑端在生成正文后会立即显示并继续下一章，而手机端则会等待该章的“润色/优化”彻底完成后才生成接下来的正文，导致生成效率低下。

### 根因分析

1. **关键配置丢失**：在 [`src/App.tsx`](src/App.tsx) 中，传递给 `MobileWorkflowEditor` 的 `globalConfig` 缺少了 `asyncOptimize` (异步优化) 属性。
2. **默认值偏差**：在手机端工作流中，由于缺失该配置，`AutoWriteEngine` 默认可能回退到了同步模式（Sync），即必须等待当前章优化结束。
3. **Prop 传递断路**：`MobileWorkflowEditor` 缺失了 `updateAsyncOptimize` 的回调传递，导致手机端无法正确同步主设置中的异步优化开关。

### 修复方案

1. **补全配置链路 ([`src/App.tsx`](src/App.tsx))**：
    * 在 `MobileWorkflowEditor` 的 `globalConfig` 属性中补齐了 `asyncOptimize` 状态。
    * 增加了 `updateAsyncOptimize` 回调，确保双端配置实时同步。
2. **增强移动端容错 ([`src/components/MobileWorkflowEditor.tsx`](src/components/MobileWorkflowEditor.tsx))**：
    * 在初始化引擎配置时，为 `asyncOptimize` 增加了 `?? true` 的防御性默认值，确保在配置意外丢失时优先保持“生成不中断”的高效体验。

### 修复效果

手机端工作流的正文生成逻辑现在与电脑端完全一致：

* **不再等待优化**：正文生成后立即写入目录并开启下一章创作。
* **背景异步优化**：润色任务将在后台静默运行，生成的优化版会自动更新到版本历史中，不会阻塞主创作流程。
* **体验对齐**：用户在手机上也能享受到与电脑端同等流畅的全自动批量创作体验。

## 第十五次修复：完善工作流日志打印与优化模型对齐 (2024-10-28)

### 问题描述

用户反馈：

1. **日志参数缺失**：手机端在 PowerShell 打印的 AI 请求日志中缺少关键参数（如 Max Tokens, Stream 等）。
2. **模型调用不一致**：工作流在触发自动优化（分析与润色）时，调用的模型依然是全局默认模型，而没有遵循主设置中专门为“优化”和“分析”指定的模型。

### 根因分析

1. **日志模板过简**：[`src/components/MobileWorkflowEditor.tsx`](src/components/MobileWorkflowEditor.tsx) 中的 `terminal.log` 模板未包含新引入的控制参数。
2. **引擎配置盲区**：`AutoWriteEngine` 的配置接口 [`AutoWriteConfig`](src/utils/auto-write/types.ts) 缺少 `optimizeModel` 和 `analysisModel` 字段，导致在 [`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts) 中执行优化任务时无法获取专用模型设置，只能降级使用全局 `model`。

### 修复方案

1. **扩展配置定义 ([`src/utils/auto-write/types.ts`](src/utils/auto-write/types.ts))**：
    * 在 `AutoWriteConfig` 接口中增加了 `optimizeModel` 和 `analysisModel` 可选字段。
2. **对齐优化模型逻辑 ([`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts))**：
    * 修改了 `optimizeChapter` 方法，在进行“优化前分析”和“正文优化/润色”请求时，优先使用配置中的专用模型。
    * 同步更新了日志打印，确保显示的 Model 与实际请求一致。
3. **完善移动端日志 ([`src/components/MobileWorkflowEditor.tsx`](src/components/MobileWorkflowEditor.tsx))**：
    * 在移动端工作流执行日志中补全了 `Max Tokens` 和 `Stream` 状态的展示。

### 修复效果

* **日志透明化**：开发者和用户可以通过日志清晰看到移动端请求的所有核心 AI 参数。
* **模型精准化**：自动优化任务现在能正确识别并调用用户在全局设置中指定的专用优化模型（如更擅长润色的模型），不再一刀切。

## 第十六次修复：彻底解决工作流正文生成阻塞优化的异常 (2024-10-28)

* **Bug 描述**：工作流执行“正文生成”节点时，即便开启了“异步优化”，手机端依然可能在生成一两章后显示“正在优化”并停滞，不继续生成后续章节。
* **根因分析**：
    1. **并发锁死**：`AutoWriteEngine.optimizeChapter` 内部包含一个 `while` 循环，当后台优化任务达到并发上限（默认 3 个）时会进行 `await` 等待。在工作流这种批量生成场景下，这会导致主创作循环被阻塞。
    2. **强制等待逻辑**：`AutoWriteEngine.run` 方法末尾存在一个等待所有活跃优化任务完成的逻辑，导致节点无法及时标记为 `completed`。
    3. **状态合并竞争**：`App.tsx` 中针对 `MobileWorkflowEditor` 的 `onUpdateNovel` 回调逻辑与 `WorkflowEditor` 不完全一致，导致在异步优化结果返回时，章节状态的合并可能产生冲突。
* **解决方案**：
    1. **优化并发策略 ([`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts))**：修改 `optimizeChapter`，增加 `isAsync` 参数。在异步模式下，若并发达到上限，直接跳过自动优化并记录日志，绝不阻塞主创作流程。
    2. **解除末尾阻塞 ([`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts))**：从 `AutoWriteEngine.run` 中移除强制等待后台优化任务完成的逻辑，实现真正的后台化。
    3. **对齐双端逻辑**：
        * 移除 `MobileWorkflowEditor.tsx` 中对 `asyncOptimize` 的手动兜底，统一由 `globalConfig` 驱动。
        * 重构 `App.tsx` 中的移动端 `onUpdateNovel` 回调，采用与电脑端一致的“增量合并+折叠状态保护”策略。
* **修复效果**：手机端工作流正文生成逻辑与电脑端完美对齐。生成完一章后，润色任务在后台独立运行，工作流会立即推进至下一章创作，彻底消除了“正在优化”导致的停滞现象。
