# 终极方案：字典式深度映射返回规范 (无需改动代码)

针对条目内包含大量不固定名称、不固定数量的子条目（深度）的需求，本方案利用系统解析器的“全值提取”特性实现。

## 1. 核心原理：匿名对象投影逻辑

系统解析器（`normalizeGeneratorResult`）在处理对象的第二个字段时，具备以下隐藏逻辑：

- 如果该字段是一个 **Object (字典)**，系统会遍历该对象的所有 **Value**。
- 如果 Value 是字符串或数字，则拼接。
- 如果 Value 仍是对象，则**递归调用 `JSON.stringify`**。

## 2. 方案：Key-As-Value 字典封装法

既然子条目的名字（Key）不固定，为了让 Key 也能在界面上显示出来，必须要求 AI 将其转化为**“键值对字符串”**。

### AI 提示词指令要求 (直接复制)
>
> “请按照以下格式返回 JSON：
>
> 1. 每个主条目是一个对象。
> 2. 第一个字段为条目标题。
> 3. 第二个字段名为 'details'，它必须是一个字典对象。
> 4. 'details' 字典中的每一个键值对，代表一个子条目。
> 5. **重要**：请确保字典的 Value 中包含其对应的 Key，格式为：`"Key名: Value内容"`。”

### JSON 返回示例

```json
[
  {
    "name": "魔法体系深度设定",
    "details": {
      "属性分级": "属性分级: 分为地、火、水、风、光、暗、空七大原始元素。",
      "施法媒介": {
        "杖类": "施法媒介-杖类: 适合远程大范围咒语，增幅倍率 1.5x。",
        "符文": "施法媒介-符文: 适合陷阱与瞬发，隐蔽性极高。",
        "特殊": "施法媒介-特殊: 包含血液、阴影等禁忌媒介。"
      },
      "等级限制": "等级限制: 1-3级为见习，4-6级为精英，7级以上为大师。"
    }
  }
]
```

## 3. 该方案的优势 (解决您的痛点)

1. **子条目个数不固定（深度）**：字典对象可以包含任意数量的 Key，系统会全部提取。
2. **子条目名字不固定**：AI 可以根据剧情逻辑随意生成 Key 名（如“杖类”、“符文”），因为 Key 被重复写在了 Value 中，系统在拼接时会将其作为正文显示。
3. **多级嵌套支持**：如上例中的“施法媒介”项下还有子项，系统会将其自动序列化，确保数据不丢失。

## 4. UI 呈现效果

- **列表显示**：魔法体系深度设定
- **内容详情**：属性分级: 分为地... 施法媒介-杖类: 适合... 施法媒介-符文: 适合... 等级限制: 1-3级...

## 总结建议

如果您希望在不改代码的情况下，让系统“吃下”任何奇形怪状的深度数据，**“Key-As-Value 字典封装法”**是唯一的万能方案。它将 Key 的显示责任交给了 AI 内容生成，而将存储和提取逻辑留给了系统现有的自动投影机制。
