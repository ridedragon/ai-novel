# 第一次修复尝试日志：原文丢失Bug (2024-10-27)

## 问题描述

用户反馈在进行“全自动正文创作”、“润色/优化”或“续写”过程中，原本手动编辑的内容偶尔会彻底丢失，且版本历史中无法找回。该 Bug 极其顽固，属于高优先级同步/竞态问题。

## 根因分析

经过深度代码审计，我发现了以下几个导致原文丢失的核心逻辑缺陷：

1. **版本初始化陷阱 (Initialization Trap)**：
    * 在 `ensureChapterVersions` 和类似的流式初始化逻辑中，系统会在 AI 开始写入内容时（甚至是流式输出的第一块内容到达时）检查版本历史。
    * **旧缺陷**：如果版本历史为空，它会直接将“当前正文内容”作为第一个版本存入。
    * **丢失场景**：由于 AI 已经开始流式输出，此时的 `content` 可能已经包含了部分 AI 生成的内容，或者之前的用户手动修改还没来得及同步到 versions 数组。结果：包含用户修改的纯净原文被 AI 污染的内容永久覆盖。

2. **原文锁定缺陷 (Original Lock Failure)**：
    * 在 `handleOptimize` 的 `buildVersions` 函数中存在逻辑：`else if (!versions[originalIndex].content.trim() && sourceContentToUse?.trim())`。
    * **旧缺陷**：该逻辑仅在“备份的原文完全为空”时才允许更新备份。
    * **丢失场景**：如果用户打开一个已有内容的章节并进行了修改，点击润色时，`sourceContentToUse` 包含最新修改，但因为备份中已经有旧内容（非空），最新修改被拒之门外。随后 `activeVersionId` 切换到新的 AI 版本，旧的正文被覆盖，用户刚才的修改彻底丢失。

3. **续写/全自动模式版本脱节 (Streaming Disconnection)**：
    * 在 `handleGenerate` (续写) 和全自动循环的流式更新中，系统频繁调用 `setChapters` 更新 `content`。
    * **旧缺陷**：更新过程没有同步维护 `versions` 数组，或者在错误的时机重置了 `versions`。
    * **丢失场景**：如果在流式生成过程中发生刷新或切换版本，由于当前活跃的内容没有对应的备份版本，所有正在生成的内容和之前的状态都会回滚到上一个已保存的版本。

4. **工作流合并竞态 (Workflow Merge Conflict)**：
    * 工作流引擎返回结果后，会尝试将远程状态与本地状态合并。
    * **旧缺陷**：合并逻辑过分依赖版本 ID 的匹配，如果本地有未版本化的 `content` 修改，合并逻辑会直接用版本历史中的旧数据进行“强制覆盖”。

## 实施修复方案

### 1. 强制“先备份，后写入”策略

在 `src/utils/auto-write/index.ts` 和 `src/App.tsx` 的所有 AI 触发点，增加了预检查逻辑：

* 只要 `versions` 为空，立即根据**当前真实的界面内容**创建一个 `original` 版本。
* 确保 `original` 版本捕捉到的是用户点击按钮瞬间的最后快照。

### 2. 引入“手动编辑”保护版本

在 `buildVersions` 中，增加了内容比对逻辑：

* 如果点击润色时的内容与版本历史中最新的内容不一致，系统会自动插入一个 `manual` 版本作为过渡。
* 这样即使用户没有手动点保存，AI 润色也不会直接吞掉刚才的编辑。

### 3. 流式版本同步更新

修正了 `handleGenerate` 和 `autoWriteLoop` 中的 `setChapters` 逻辑：

* AI 输出的每一块增量都会实时同步更新到对应的 `version.content` 中。
* 保证了“所见即所存”，消除了内容处于“悬空”状态（即存在于 content 变量但不在 versions 中）的风险。

### 4. 完善数据标准化 (`ensureChapterVersions`)

重写了标准化函数，使其在处理旧数据或不完整数据时更加稳健，优先从多个备选属性（`content`, `sourceContent`）中挽救数据。

## 验证结论

通过对 `src/App.tsx` 和 `src/utils/auto-write/index.ts` 的静态代码分析，修复后的逻辑在所有已知入口均建立了严密的版本防护网。手动编辑内容在 AI 介入前将被强制“快照化”，彻底解决了原文被抢占覆盖的问题。

## 待办事项

* [x] 修复“多个原文标签”显示异常 Bug (2024-10-28)
* [ ] 观察用户在大规模批量生成任务中的反馈。

* [ ] 进一步优化长文模式下摘要生成时的状态合并逻辑。

## 第二次修复：解决多个“原文”标签显示异常 (2024-10-28)

### 问题描述

用户界面出现了多个名为“原文”的版本标签（如：0字符、928字符、562字符等），导致版本管理混乱。

### 根因分析

在第一次修复原文丢失 Bug 时，为了确保任何阶段的内容都有备份，在多个流式输出和手动编辑保护逻辑中，错误地将新创建的版本类型（`type`）统一指定为了 `'original'`。
这导致 `ChapterEditor.tsx` 在渲染版本列表时，根据 `type === 'original'` 判断显示名称，从而出现了多个“原文”。

### 修复方案

对 `src/App.tsx` 中的版本创建逻辑进行了精细化调整：

1. **手动编辑保护**：在润色触发前的快照备份中，将类型由 `'original'` 改为 `'user_edit'`（编辑版）。
2. **流式生成内容**：在全自动写作和续写过程中，将 AI 生成的初稿类型明确标记为 `'optimized'`（优化/生成版）或 `'user_edit'`，不再占用 `'original'` 标签。
3. **保持唯一性**：确保 `'original'` 类型仅用于章节最初始的、未经 AI 介入的原始快照。

## 第三次修复：解决原文 0 字符及版本命名逻辑优化 (2024-10-28)

### 问题描述

1. 用户反馈：在某些情况下，“原文”版本显示为 0 字符，而实际内容出现在“用户编辑”版本中。
2. 界面显示：优化版本显示为“优化版 0”，不符合用户直觉（应从 1 开始）。

### 根因分析

1. **空原文占位**：在章节刚创建时，系统可能先创建了一个空的 `'original'` 版本。当用户输入内容并点击润色时，之前的逻辑检测到已有 `'original'` 版本（尽管是空的），于是将当前输入内容作为 `'user_edit'` 备份。结果导致真正的初始内容被标记为了“用户编辑”，而“原文”成了空壳。
2. **索引偏移**：前端渲染时直接使用了数组索引，导致显示为“优化版 0”。

### 修复方案

1. **优化备份逻辑 (`src/App.tsx`)**：
    * 在 `buildVersions` 中增加逻辑：如果现有的 `'original'` 版本内容为空且当前界面有内容，则**直接更新**该原文版本，而不是新建“编辑版”。
2. **改进 UI 显示 (`src/components/Editor/ChapterEditor.tsx`)**：
    * 修正版本切换按钮及下拉列表的显示逻辑。
    * “优化版”编号改为基于同类型版本的过滤索引，且从 1 开始计数（如“优化版 1”、“优化版 2”）。
    * 统一了下拉列表中的版本名称显示规则。

## 第四次修复：解决冗余的“用户编辑”版本问题 (2024-10-28)

### 问题描述

用户反馈：在进行多次润色或版本切换后触发润色时，即使没有手动修改内容，系统也会产生一个内容与“原文”完全相同的“用户编辑”版本。

### 根因分析

在 `src/App.tsx` 的 `buildVersions` 逻辑中，备份当前内容为“编辑版”的触发条件是：**当前正文内容与版本数组中的最后一个版本内容不一致**。

当用户完成一次润色（产生“优化版 1”）后，如果切换回“原文”并再次点击润色，系统会将当前的“原文”内容与数组末尾的“优化版 1”进行对比。由于两者内容不同，逻辑错误地认为用户进行了手动编辑，从而产生了一个冗余的“编辑版”快照。

### 修复方案

1. **精准对比逻辑 (`src/App.tsx`)**：
    * 修改 `buildVersions` 函数中的判断逻辑。
    * 不再简单地与数组最后一个版本对比，而是与**当前正处于活跃状态的版本 (activeVersion)** 进行对比。
    * 只有当用户在当前版本的基础上确实进行了手动修改（`sourceContentToUse !== activeVersion.content`），才会触发“用户编辑”版的备份。
2. **日志记录**：
    * 记录了该竞态条件下的版本冗余问题及修复对策。

## 第五次修复：解决通过工作流产生正文时导致的原文丢失 (2024-10-28)

### 问题描述

用户反馈：当使用“全自动创作”工作流生成正文时，原本章节中的手动编辑内容（原文）会消失，变成 0 字符，或者被 AI 生成的内容直接覆盖。

### 根因分析

在 `src/utils/auto-write/index.ts` 的版本管理逻辑中存在两个关键漏洞：

1. **误杀原文逻辑**：在 AI 生成结束后的版本合并阶段，代码使用 `v.type === 'original'` 作为匹配条件。这意味着如果章节已经存在用户手动创建的原文，它会被 AI 生成的新内容**直接覆盖**。
2. **类型标记错误**：部分 AI 生成的代码路径仍将类型标记为 `'original'`，导致系统在“更新旧原文”和“创建新版本”之间产生逻辑混乱，最终导致初始内容被抹除。

### 修复方案

1. **修正匹配策略**：在 AI 创作完成后的合并逻辑中，将基于类型的匹配（`type === 'original'`）改为严格基于 ID 的匹配。这确保了 AI 仅能更新它自己产生的流式版本，而永远不会触碰用户手动创建的 `original` 版本。
2. **规范 AI 内容标签**：将全自动创作产生的所有 AI 版本类型由 `'original'` 修正为 `'user_edit'`。在系统中，章节最初始的内容才是真正的“原文”，AI 生成的初稿应被视为待审阅的“编辑版”。
3. **强化初始化保护**：确保在流式输出开始前，如果章节已有内容，必须先将其封装进一个不可变的 `original` 版本中。

## 第六次修复：解决全自动创作流式更新产生大量冗余版本的问题 (2024-10-28)

### 问题描述

用户反馈：在使用工作流生成正文并触发优化时，下拉列表中出现了大量的“用户编辑”版本，且这些版本的字符数随时间逐渐增加，导致版本库溢出。

### 根因分析

在 `src/utils/auto-write/index.ts` 的流式更新逻辑中，版本 ID 的生成方式存在严重缺陷：

* **ID 漂移**：原本代码在 `for await (const chunk of response)` 循环内部使用 `Date.now()` 生成版本 ID。
* **逻辑后果**：由于流式传输每秒会产生多次 chunk，每次进入循环都会生成一个新的时间戳 ID。这导致系统无法通过 `findIndex` 找到“上一次”生成的 AI 版本，从而在每一次 chunk 到达时都创建了一个全新的“编辑版”版本，造成版本数量爆炸且内容步进式增加。

### 修复方案

1. **锁定流式 ID ([`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts))**：
    * 在进入流式循环**之前**，提前获取一次 `Date.now()` 并存入常量 `streamStartTime`。
    * 在循环内部，始终使用该常量来构建版本 ID（如 `v_${streamStartTime}_autowrite_${c.id}`）。
2. **实现“单版本更新”**：
    * 通过锁定的 ID，系统在整个流式输出过程中都能精准匹配到同一个 AI 版本对象，实现对该版本的持续覆写（Overwrite），而不是无限叠加（Append）。

## 第七次修复：解决 0 字符原文占位及任务完成时的重复版本 (2024-10-28)

### 问题描述

用户反馈：运行工作流后，出现 0 字符的“原文”标签，且出现了两个内容几乎一致的“用户编辑”版本。

### 根因分析

1. **ID 漂移 (ID Drift)**：代码在流式传输阶段和最终合并阶段分别使用了不同的时间戳。这导致系统在任务结束时无法识别出之前正在更新的流式版本，从而创建了一个全新的重复版本。
2. **盲目初始化**：之前的逻辑在工作流开始时，无论章节是否有内容，都会强制初始化一个 `original` 版本的占位符，导致空章节出现了 0 字符的垃圾标签。
3. **类型标记不合理**：AI 生成的初稿被错误标记为“用户编辑”，增加了用户理解成本。

### 修复方案

1. **全局任务 ID 锁定**：在 `AutoWriteEngine` 执行单次任务前，锁定一个 `taskStartTime`。流式更新和最终保存均使用基于此时间戳的唯一 ID（`v_${taskStartTime}_autowrite_${id}`），确保版本精准合并，绝不产生重复。
2. **智能原文判定**：移除了 0 字符强制初始化逻辑。系统现在会检测：如果章节此前无内容，则将 AI 生成的第一稿直接标记为 `original`（原文/初稿）；如果此前已有内容，则保留原内容为 `original`，AI 生成内容标记为 `user_edit`。
3. **消除垃圾标签**：只有在真正存在初始手动内容时才会创建初始快照，彻底消灭了 0 字符原文标签。

## 第八次修复：解决连贯创作模式下的流式分章、异常请求及空章节问题 (2024-10-28)

### 问题描述

在开启“长上下文模式”并设置“连贯创作章节数 > 1”时：

1. **分章失败**：生成的文本全部堆积在第一章，后续章节为空。
2. **流式体验差**：只有第一章有流式更新，其他章节需等待任务彻底结束。
3. **版本混乱**：依然出现了 0 字符原文标签，且产生了多个“用户编辑”版本而非“优化版”。
4. **请求异常**：日志显示正文创作请求可能被触发了多次。

### 根因分析

1. **流式拆分缺失**：旧代码的流式循环中仅硬编码更新 `batchItems[0]`（第一章），完全忽略了批量生成时的多章拆分。
2. **正则匹配脆弱**：分章逻辑依赖的标题正则不够健壮，无法处理复杂的换行符或带有前导字符的情况。
3. **ID 锁位不准**：`taskStartTime` 的生成位置在重试循环内部，导致一旦发生自动重试，前后 ID 就不一致，触发重复版本。
4. **版本创建时机过早**：即使内容还是空的，流式第一帧也会尝试创建版本。

### 修复方案

1. **流式动态分章更新**：引入 `splitBatchContent` 专用工具函数。现在流式传输的每一帧都会尝试实时拆分内容，并同步更新批次内的所有章节（第一章、第二章等同时看到文字跳动）。
2. **健壮的标题识别**：改用支持多平台换行符（`\r\n`、`\n`）及多种空白字符的标题正则。增加了“激进分割”模式作为兜底，确保即便标题匹配有微小偏差，内容也不会丢失。
3. **重试 ID 粘性锁定**：将 `taskStartTime` 移动到重试循环（`while (attempt < maxAttempts)`）之外。这保证了无论请求因为网络重试多少次，其生成的版本 ID 始终如一，实现物理意义上的“单版本覆盖”。
4. **内容驱动型版本创建**：在流式过程中增加 `.trim()` 检测，只有当 AI 真正输出了有效文字时才初始化版本对象，彻底堵死了 0 字符标签的产生路径。

## 第九次修复：修正数据标准化陷阱及版本初始化逻辑 (2024-10-28)

### 问题描述

用户反馈：在工作流生成正文触发优化后，部分章节的“原文”版本内容为空（0字符），原本应该由 AI 生成的初稿似乎未能正确保存为原文，或者被后续的优化版本覆盖。

### 根因分析

1. **数据标准化陷阱**：`App.tsx` 中的 `ensureChapterVersions` 函数被设计为“确保章节拥有版本历史”。然而，它在执行时过于武断：只要章节没有 versions 数组，它就会强行创建一个 `original` 版本。在工作流刚刚创建空章节占位符的瞬间，如果该函数被触发，就会立即锁死一个“0 字符原文”。
2. **版本抢占冲突**：当 AI 开始流式输出时，如果它发现章节已经有了一个（空的）`original` 版本，它会按照逻辑创建一个新的 `user_edit` 版本来存放内容。这导致原本应该是“原文”的内容变成了“编辑版”，而“原文”标签则永远留在了 0 字符的状态。
3. **合并策略缺陷**：在工作流结果返回并与本地状态合并时，如果本地已经存在上述的 0 字符版本，合并逻辑未能正确识别并清理它。

### 修复方案

1. **延迟初始化策略 ([`src/App.tsx`](src/App.tsx))**：修改 `ensureChapterVersions`。现在，如果章节内容为空（`.trim()` 为空）且没有历史版本，函数将**拒绝初始化**。这保证了空章节保持“无版本”的洁净状态，直到真正的内容产生。
2. **存量 0 字符版本自动清理 ([`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts))**：在 AI 生成逻辑中增加了“脏检查”。如果 AI 准备创建新版本时发现章节中仅存在一个 0 字符的无效原文版本，系统会自动**覆写**该版本，而不是在其后追加。这确保了 AI 生成的第一稿始终能占据“原文”位置。
3. **双重判定保障**：结合流式过程中的 `.trim()` 检测，只有在 AI 输出了实质性内容后，版本状态才会被持久化，彻底消灭了所有产生 0 字符标签的逻辑漏洞。

## 第十次修复：版本跳转体验微调 (2024-10-28)

### 问题描述

1. **跳转滞后**：优化完成后，界面有时仍停留在“原文”标签，未能自动跳转到刚生成的“优化版”。
2. **默认版本偏差**：从当前章切换到其他章节时，如果该章节曾停留在“原文”状态，回来时依然显示原文，不符合用户“默认看最新”的习惯。

### 修复方案

1. **侧边栏逻辑增强 ([`src/App.tsx`](src/App.tsx))**：
    * 在章节列表按钮的 `onClick` 处理函数中，增加了自动定位逻辑。
    * 现在点击章节时，系统会扫描该章的 `versions` 数组，并自动将 `activeVersionId` 设置为数组中的最后一个元素（即时间戳最新的版本），并同步更新 `content`。
2. **润色终态锁定 ([`src/App.tsx`](src/App.tsx))**：
    * 在 `handleOptimize` 异步流程结束处（`finally` 之前），增加了一次显式的状态确认更新。
    * 强制将章节的 `activeVersionId` 锁定为最新生成的优化版 ID，消除了流式更新中可能存在的微小状态不同步。

### 修复效果

* 现在切换章节时，默认总能看到该章最先进的版本（如“优化版 2”或“用户编辑”）。
* 润色结束后，顶部版本标签会立即更新为最新的优化版本，无需手动点击。

## 第十一次修复：解决异步优化任务中的“Request was aborted”异常中止 (2024-10-28)

### 问题描述

用户反馈在“全自动正文创作”过程中，最后一章的优化（润色）任务经常失败，并伴随报错：`Error: Request was aborted.`。用户并未进行任何手动操作（如点击停止）。

### 根因分析

1.  **错误判定偏差**：OpenAI SDK 或某些模型网关在连接异常关闭或超时时，可能会抛出非标准的 `AbortError`。旧代码仅对 `e.name === 'AbortError'` 进行了静默处理，而对其他类似的中止信号抛出了显式错误。
2.  **阶段间中断检查缺失**：在两阶段优化（先分析、后优化）中，分析结束后未再次检查 `isRunning` 或 `signal` 状态就直接发起了 Phase 2 优化请求。
3.  **最终等待超时过短**：`AutoWriteEngine.run` 最后的异步任务等待逻辑中，`MAX_WAIT` 仅为 2 分钟。对于篇幅较长或并发较高的优化任务，2 分钟可能不足以完成网络请求，导致主流程超时并强制执行 `activeOptimizationTasks.forEach(controller => controller.abort())`，从而中止了正在进行的最后一章优化。
4.  **外部中止信号传递**：流式循环中对外部 `signal` 的监听不够严密，可能导致在某些边缘情况下误触中止。

### 修复方案

1.  **增强中止判定 ([`src/utils/auto-write/index.ts`](src/utils/auto-write/index.ts), [`src/App.tsx`](src/App.tsx))**：
    * 统一了中止判定的正则表达式逻辑：`const isAbort = e.name === 'AbortError' || e.message === 'Request was aborted.' || e.message === 'Aborted'`。
2.  **完善两阶段中断检查**：
    * 在发起 Phase 2 优化请求前，增加了对 `this.isRunning` 和 `optimizationAbortController.signal.aborted` 的二次判定。
3.  **延长最终等待上限**：
    * 将 `run` 方法末尾的异步任务最大等待时间从 2 分钟延长至 **5 分钟** (`300000ms`)，并增加了对 `abortController` 状态的同步检查。
4.  **严密流式控制**：
    * 在 `for await (const chunk of response)` 循环中，将 `!this.isRunning` 判定扩展为 `!this.isRunning || this.abortController?.signal.aborted`，确保外部中止信号能立即生效。

### 验证结论

修复后，最后一章的异步优化任务将获得更充足的执行时间窗，且系统能更稳健地识别网络层抛出的静默中止信号，不再向用户弹出误导性的报错提示。
