# “小总结的大总结”功能异常分析报告

## 1. 问题概述
用户反馈在长文模式下，自动生成的总结（小总结、大总结）存在逻辑或顺序上的 Bug。经代码审查，确认在同时触发大小总结时，章节插入顺序存在倒置问题，且上下文抓取逻辑存在隐患。

## 2. 核心 Bug 分析：插入顺序倒置

### 现象描述
当写作进度同时满足“小总结”（如每 3 章）和“大总结”（如每 6 章）的触发条件时（例如写完第 6 章），系统会自动生成两个总结章节。
当前呈现的顺序为：
1. 剧情正文（第 6 章）
2. **大总结**（1-6 章）
3. **小总结**（4-6 章）

符合逻辑的预期顺序应为：
1. 剧情正文（第 6 章）
2. **小总结**（4-6 章）
3. **大总结**（1-6 章）

### 技术根因
在 `src/App.tsx` 的 `checkAndGenerateSummary` 函数中：
1. 系统先生成“小总结”，并通过 `splice(idx + 1, 0, newChapter)` 将其插入到当前章节（第 6 章，索引为 `idx`）的**下一位置**。
   - 此时列表状态：`[... 第6章, 小总结, ...]`
2. 系统紧接着生成“大总结”，逻辑同样是查找当前章节（第 6 章）的索引 `idx`，并在 `idx + 1` 处插入。
   - 由于是插入操作，新生成的“大总结”抢占了 `idx + 1` 的位置，将原本在此处的“小总结”向后挤。
   - 最终列表状态：`[... 第6章, 大总结, 小总结, ...]`

## 3. 潜在风险：章节排序依赖 ID

### 问题描述
代码中的辅助函数 `getSnapshotStoryChapters` 使用了 `sort((a, b) => a.id - b.id)` 对故事章节进行排序。
```typescript
const getSnapshotStoryChapters = () => currentChaptersSnapshot
  .filter(c => !c.subtype || c.subtype === 'story')
  .sort((a, b) => a.id - b.id) // 风险点
```

### 风险分析
`id` 通常基于创建时间戳生成。如果用户在界面上通过拖拽重排了章节顺序（例如将后写的章节移到前面作为插叙），`id` 排序将不再代表实际的阅读顺序。
这会导致：
- 总结生成时抓取的上下文范围（Range）与实际内容不匹配。
- 剧情连贯性分析错误。

## 4. 修复建议方案

### 针对顺序倒置
**推荐方案**：
在 `checkAndGenerateSummary` 中维护一个偏移量逻辑。
- 生成小总结并插入后，记录当前已插入了一个章节。
- 生成大总结时，检测到刚才已插入了小总结，应将大总结的插入位置调整为 `idx + 2`（即插入到小总结之后），确保顺序正确。

### 针对 ID 排序
**建议**：
移除 `.sort((a, b) => a.id - b.id)`，直接信任 `currentNovel.chapters` 数组本身的顺序。用户在界面上的排序已经反映在数组索引中，这才是最准确的逻辑顺序，能确保生成的总结与用户看到的剧情流一致。

## 5. 结论
当前代码主要存在插入逻辑导致的顺序问题（大总结挤占小总结位置），以及潜在的排序依赖问题。在不修改代码的前提下，目前只能通过手动拖拽调整顺序来规避。建议在后续更新中修复上述逻辑。
