# 循环节点（Loop Node）执行失效原因分析说明

## 1. 问题描述

用户反馈：工作流中循环节点设置次数为 2，但在实际运行过程中没有进行循环操作，直接跳过或仅执行了一次。

## 2. 核心原因分析

经过对 `src/components/WorkflowEditor.tsx` 及执行引擎逻辑的审计，确定了以下故障点：

### A. 状态持久化导致的计数器污染（主因）

- **现象**：系统会将每个节点的 `currentIndex`（当前循环索引）持久化到 IndexedDB。
- **原因**：如果上一次运行因报错、手动停止而中断，循环节点的 `currentIndex` 可能已经停留在 `1` 或更高。
- **后果**：当用户再次启动工作流时，若非从索引 0 开始（全量运行），系统不会触发全局重置。循环节点会读取到旧的 `currentIndex=1`。计算 `currentLoopIndex = 1 + 1 = 2`，此时 `2 < 2`（Count）判断为假，导致系统认为循环已完成，从而直接跳过回跳逻辑。

### B. 重置逻辑触发条件过窄

- **源码位置**：`WorkflowEditor.tsx` 第 2442-2460 行。
- **问题**：`resetNodeData` 逻辑仅在 `startIndex === 0` 时触发。
- **后果**：如果用户选择“从指定节点开始”或“从停止处继续”，循环计数器不会被归零，导致继承了历史错误状态。

### C. 缺乏对物理“回跳连线”的实时监控

- **现状**：工作流执行器主要按线性排序列表驱动。
- **问题**：如果用户连线为 `循环节点 -> 节点A -> 循环节点`，当执行到节点A结束时，系统默认会继续寻找线性列表中的下一个节点，而不会主动观察是否有连线指向前面的循环节点。这导致物理上的“闭环”无法触发逻辑上的“回跳”。

### D. 循环结束后的“逃离”困难

- **问题**：如果循环节点放在循环体之前（Head模式），当循环次数达到后，如果系统继续按顺序执行，则会再次进入循环体。
- **后果**：循环虽然在逻辑上结束了，但执行指针依然陷在循环体中无法跳出。

## 3. 修复方案建议

### 3.1 增强重置逻辑

无论从哪个节点启动，系统都会扫描后续路径并重置所有 `loopNode` 的计数器。

### 3.2 引入“主动回跳检测”逻辑

在**每一个节点**执行完毕后，立即检查其输出连线。如果发现连线指向一个已执行过的 `loopNode`，则强制将执行指针跳回该节点，实现真正的物理闭环驱动。

### 3.3 引入“逃离循环”跳过逻辑

当 `loopNode` 判定循环结束时，主动扫描所有连回该节点的物理路径，并直接将执行指针跳转到这些路径的“尾部”之后，确保能正确跳出循环。

### 3.4 拓扑排序优化

改进破局策略，优先选择 `loopNode` 作为逻辑入口点，确保执行顺序符合视觉逻辑。

## 4. 预期修正后的表现（Count = 2）

1. **第 1 次到达**：`currentIndex=0` -> `currentLoopIndex=1`。`1 < 2` 成立 -> **执行回跳**。
2. **第 2 次到达**：`currentIndex=1` -> `currentLoopIndex=2`。`2 < 2` 不成立 -> **结束循环**。
3. **最终效果**：循环体代码块被完整执行 **2 次**，符合用户预期。

---
*文档编制：Kilo Code (Architect Mode)*
*日期：2024-05-20*
